import * as fs from 'fs';
import * as fsp from 'fs/promises';
import * as chalk from 'chalk';
import { toJson as parseXml } from 'xml2json';
import { admin } from './admin';
import { logInfo, logError, compileTimeConfig } from './common';
import { TypeScriptCompilerOptions, transpileOnce, transpileWatch } from './run-typescript';
import { MyPackOptions, MyPackResult, pack } from './run-mypack';

function getTypescriptEntry(app: string) {
    return `src/${app}/server/index.ts`;
}
const typescriptOptions: TypeScriptCompilerOptions = {
    sourceMap: true,
    outDir: '/vbuild',
    readFileHook: (fileName, originalReadFile) => {
        let content = originalReadFile(fileName);
        if (!fileName.endsWith('.d.ts')) {
            for (const configName in compileTimeConfig) {
                content = content.split(configName).join(compileTimeConfig[configName]);
            }
        }
        return content;
    },
    watchReadFileHook: (fileName, encoding, originalReadFile) => {
        let content = originalReadFile(fileName, encoding);
        if (!fileName.endsWith('.d.ts')) {
            for (const configName in compileTimeConfig) {
                content = content.split(configName).join(compileTimeConfig[configName]);
            }
        }
        return content;
    },
} as TypeScriptCompilerOptions;
function createMyPackOptions(app: string, files: MyPackOptions['files'], lastResult?: MyPackResult): MyPackOptions {
    return {
        type: 'lib',
        entry: `/vbuild/${app}/server/index.js`,
        files,
        sourceMap: true,
        output: `dist/${app}/server.js`,
        printModules: true,
        minify: true,
        lastResult,
    };
}

interface APIConfig {
    namespace?: string, // namespace default to default, this is not used for now (all regarded as default)
    name: string, 
    method: string, 
    path: string, 
    'body-type'?: string, 
    'body-name'?: string, 
    'return-type'?: string,
}
interface APIConfigFile {
    version: string,
    api: APIConfig[],
}

async function generateEntry(app: string): Promise<boolean> {
    logInfo('fcg', chalk`generate {yellow src/${app}/server/index.ts}`);

    const apixml = await fsp.readFile(`src/${app}/api.xml`, 'utf-8');
    const { version, api: apis } = parseXml(apixml, { object: true })[`${app}-api`] as APIConfigFile;

    let resultJs = '// ATTENTION:\n'
        + '// This code was generated by a tool.\n'
        + '// Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.\n\n';
    if (apis.length == 0) {
        resultJs += "// empty\n";
        await fsp.writeFile(`src/${app}/server/index.g.ts`, resultJs);
        logInfo('fcg', 'generate completed with empty');
        return true;
    }

    const parameterTypes = ['id', 'number', 'string', 'boolean', 'date', 'datetime'];
    const parameterTypeToPattern: { [parameterType: string]: string } = { 'id': '\\d+', 'number': '\\d+', 'string': '.+', 'boolean': '(true|false)', 'date': '\\d{6}', 'datetime': '\\d{12}' };
    const parameterTypeToFU: { [parameterType: string]: string } = { 'id': 'Id', 'number': 'Number', 'string': 'String', 'boolean': 'Boolean', 'date': 'Date', 'datetime': 'DateTime' }; // to first upper // forget how this convention is called

    // because colon is only used for capture type, so validators can be prepared by this
    const validators: string[] = [];
    for (const captureType of parameterTypes) {
        if (apis.some(api => api.path.includes(`:${captureType}`))) { 
            validators.push(`validate${parameterTypeToFU[captureType]}`); 
        }
    }
    if (apis.some(api => ['PUT', 'POST', 'PATCH'].includes(api.method))) { validators.push('validateBody'); }
    resultJs += `import { WebContext, ${validators.join(', ')} } from '../../shared/api-server';\n`;
    resultJs += `import { MyError } from '../../shared/error';\n`;
    resultJs += `import { ${apis.map(api => api.name).join(', ')} } from './default';\n`;
    resultJs += '\n';

    resultJs += `export async function dispatch(ctx: WebContext) {\n`;
    resultJs += `    let match: RegExpExecArray;\n`;
    resultJs += `    if (!ctx.path.startsWith('/${app}/v${version}')) { throw new MyError('not-found', 'invalid invocation version'); }\n`
    resultJs += `    const methodPath = \`\${ctx.method} \${ctx.path.slice(${app.length + version.length + 3})}\`;\n`; // 3: /{app}/v{version}
    resultJs += '\n';

    for (const api of apis) {
        const { name: apiName, method, path } = api;
        const [bodyType, returnType] = [api['body-type'], api['return-type']];

        let resultRegex = method + ' ' + path;
        const parameters: { name: string, type: string }[] = [];
        do {
            const match = /\{(?<parameterName>[\w\_]+):(?<parameterType>\w+)\}/.exec(resultRegex);
            if (!match) { break; }

            if (parameters.length == 10) {
                // this is actually prevent infinite loop while developing
                logError('fcg', `api ${apiName} too many parameters`);
                return false;
            }

            const [parameterName, parameterType] = [match.groups['parameterName'], match.groups['parameterType']];
            if (!parameterTypes.includes(parameterType)) {
                // fcg: fps code generation
                logError('fcg', `api ${apiName} parameter ${parameterName} invalid type ${parameterType}`);
                return false;
            }

            resultRegex = resultRegex.slice(0, match.index) + `(?<${parameterName}>${parameterTypeToPattern[parameterType]})` + resultRegex.slice(match.index + parameterName.length + parameterType.length + 3);
            parameters.push({ name: parameterName, type: parameterType });
        } while (true);
        resultRegex = resultRegex.split('/').join('\\/');
        resultJs += `    match = /^${resultRegex}$/.exec(methodPath); if (match) {\n`;

        resultJs += '        ';
        if (returnType && returnType != 'void') {
            resultJs += `ctx.body = `;
        }
        resultJs += `await ${apiName}(ctx.state`;
        for (const { name: parameterName, type: parameterType } of parameters) {
            resultJs += `, validate${parameterTypeToFU[parameterType]}('${parameterName}', match.groups['${parameterName}'])`;
        }
        if (bodyType) {
            resultJs += `, validateBody(ctx.request.body)`;
        }
        resultJs += ');\n';

        if (method == 'POST') {
            resultJs += `        ctx.status = 201;\n`;
        } else if (method == 'DELETE') {
            resultJs += `        ctx.status = 204;\n`;
        }

        resultJs += `        return;\n`;
        resultJs += `    }\n`;
    }

    resultJs += `\n`;
    resultJs += `    throw new MyError('not-found', 'invalid invocation');\n`;
    resultJs += '}\n';

    await fsp.writeFile(`src/${app}/server/index.ts`, resultJs);
    logInfo('fcg', 'generate completed');
    return true;
}

async function buildOnce(app: string) {
    logInfo('mka', chalk`{yellow ${app}-server}`);

    if (!await generateEntry(app)) {
        logError('mka', chalk`{yellow ${app}-server} failed at code generation`);
        process.exit(1);
    }

    const files: MyPackOptions['files'] = [];
    if (!transpileOnce(getTypescriptEntry(app), { ...typescriptOptions, 
        writeFileHook: (name: string, content: string) => files.push({ name, content }),
    } as unknown as TypeScriptCompilerOptions)) {
        logError('mka', chalk`{yellow ${app}-server} failed at transpile typescript`);
        process.exit(1);
    }

    const packResult = await pack(createMyPackOptions(app, files));
    if (!packResult.success) {
        logError('mka', chalk`{yellow ${app}-server} failed at pack`);
        process.exit(1);
    }

    await fsp.writeFile(`dist/${app}/server.js`, packResult.jsContent);
    await fsp.writeFile(`dist/${app}/server.js.map`, packResult.mapContent);

    await admin({ type: 'reload-server', app });
    logInfo('mka', `${app}-server completed successfully`);
}

function buildWatch(app: string) {
    logInfo('mka', chalk`watch {yellow ${app}-server}`);

    // watch api.xml
    fs.watchFile(`src/${app}/api.xml`, { persistent: false }, (currstat, prevstat) => {
        if (currstat.mtime == prevstat.mtime) {
            return;
        }
        // if error, no emit and tsc watch retranspile will not be triggered
        generateEntry(app);
    });

    process.on('SIGINT', () => {
        fs.unwatchFile(`src/${app}/api.xml`);
        process.exit(0);
    });

    const files: MyPackOptions['files'] = [];
    let lastResult: MyPackResult = null;

    transpileWatch(getTypescriptEntry(app), { 
        ...typescriptOptions,
        watchWriteFileHook: (name: string, content: string) => {
            const existIndex = files.findIndex(f => f.name == name);
            if (existIndex >= 0) {
                files.splice(existIndex, 1, { name, content });
            } else {
                files.push({ name, content });
            }
        },
        watchEmit: async () => {
            const currentResult = await pack(createMyPackOptions(app, files, lastResult));
            if (currentResult.success) {
                await fsp.writeFile(`dist/${app}/server.js`, currentResult.jsContent);
                await fsp.writeFile(`dist/${app}/server.js.map`, currentResult.mapContent);
            }

            if (currentResult.hash != lastResult?.hash) {
                await admin({ type: 'reload-server', app });
            }
            lastResult = currentResult;
        },
    } as unknown as TypeScriptCompilerOptions);
    
    // initial code generation
    generateEntry(app);
}

export async function build(app: string, watch: boolean): Promise<void> {
    if (watch) {
        buildWatch(app);
    } else {
        await buildOnce(app);
    }
}